import kn, { createContext as Tr, useContext as Cr } from "react";
var Ct = { exports: {} }, Ye = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cn;
function Ar() {
  if (cn) return Ye;
  cn = 1;
  var e = kn, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(c, a, u) {
    var f, h = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), a.key !== void 0 && (d = "" + a.key), a.ref !== void 0 && (g = a.ref);
    for (f in a) r.call(a, f) && !s.hasOwnProperty(f) && (h[f] = a[f]);
    if (c && c.defaultProps) for (f in a = c.defaultProps, a) h[f] === void 0 && (h[f] = a[f]);
    return { $$typeof: t, type: c, key: d, ref: g, props: h, _owner: i.current };
  }
  return Ye.Fragment = n, Ye.jsx = o, Ye.jsxs = o, Ye;
}
var ze = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var an;
function Pr() {
  return an || (an = 1, process.env.NODE_ENV !== "production" && function() {
    var e = kn, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), c = Symbol.for("react.context"), a = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), v = Symbol.iterator, x = "@@iterator";
    function S(l) {
      if (l === null || typeof l != "object")
        return null;
      var p = v && l[v] || l[x];
      return typeof p == "function" ? p : null;
    }
    var w = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _(l) {
      {
        for (var p = arguments.length, b = new Array(p > 1 ? p - 1 : 0), E = 1; E < p; E++)
          b[E - 1] = arguments[E];
        R("error", l, b);
      }
    }
    function R(l, p, b) {
      {
        var E = w.ReactDebugCurrentFrame, A = E.getStackAddendum();
        A !== "" && (p += "%s", b = b.concat([A]));
        var k = b.map(function(C) {
          return String(C);
        });
        k.unshift("Warning: " + p), Function.prototype.apply.call(console[l], console, k);
      }
    }
    var y = !1, m = !1, T = !1, B = !1, ie = !1, H;
    H = Symbol.for("react.module.reference");
    function K(l) {
      return !!(typeof l == "string" || typeof l == "function" || l === r || l === s || ie || l === i || l === u || l === f || B || l === g || y || m || T || typeof l == "object" && l !== null && (l.$$typeof === d || l.$$typeof === h || l.$$typeof === o || l.$$typeof === c || l.$$typeof === a || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      l.$$typeof === H || l.getModuleId !== void 0));
    }
    function U(l, p, b) {
      var E = l.displayName;
      if (E)
        return E;
      var A = p.displayName || p.name || "";
      return A !== "" ? b + "(" + A + ")" : b;
    }
    function W(l) {
      return l.displayName || "Context";
    }
    function j(l) {
      if (l == null)
        return null;
      if (typeof l.tag == "number" && _("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof l == "function")
        return l.displayName || l.name || null;
      if (typeof l == "string")
        return l;
      switch (l) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case u:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case c:
            var p = l;
            return W(p) + ".Consumer";
          case o:
            var b = l;
            return W(b._context) + ".Provider";
          case a:
            return U(l, l.render, "ForwardRef");
          case h:
            var E = l.displayName || null;
            return E !== null ? E : j(l.type) || "Memo";
          case d: {
            var A = l, k = A._payload, C = A._init;
            try {
              return j(C(k));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var L = Object.assign, X = 0, Y, le, he, ce, Q, ee, et;
    function zt() {
    }
    zt.__reactDisabledLog = !0;
    function er() {
      {
        if (X === 0) {
          Y = console.log, le = console.info, he = console.warn, ce = console.error, Q = console.group, ee = console.groupCollapsed, et = console.groupEnd;
          var l = {
            configurable: !0,
            enumerable: !0,
            value: zt,
            writable: !0
          };
          Object.defineProperties(console, {
            info: l,
            log: l,
            warn: l,
            error: l,
            group: l,
            groupCollapsed: l,
            groupEnd: l
          });
        }
        X++;
      }
    }
    function tr() {
      {
        if (X--, X === 0) {
          var l = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: L({}, l, {
              value: Y
            }),
            info: L({}, l, {
              value: le
            }),
            warn: L({}, l, {
              value: he
            }),
            error: L({}, l, {
              value: ce
            }),
            group: L({}, l, {
              value: Q
            }),
            groupCollapsed: L({}, l, {
              value: ee
            }),
            groupEnd: L({}, l, {
              value: et
            })
          });
        }
        X < 0 && _("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var gt = w.ReactCurrentDispatcher, mt;
    function tt(l, p, b) {
      {
        if (mt === void 0)
          try {
            throw Error();
          } catch (A) {
            var E = A.stack.trim().match(/\n( *(at )?)/);
            mt = E && E[1] || "";
          }
        return `
` + mt + l;
      }
    }
    var bt = !1, nt;
    {
      var nr = typeof WeakMap == "function" ? WeakMap : Map;
      nt = new nr();
    }
    function qt(l, p) {
      if (!l || bt)
        return "";
      {
        var b = nt.get(l);
        if (b !== void 0)
          return b;
      }
      var E;
      bt = !0;
      var A = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var k;
      k = gt.current, gt.current = null, er();
      try {
        if (p) {
          var C = function() {
            throw Error();
          };
          if (Object.defineProperty(C.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(C, []);
            } catch (z) {
              E = z;
            }
            Reflect.construct(l, [], C);
          } else {
            try {
              C.call();
            } catch (z) {
              E = z;
            }
            l.call(C.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (z) {
            E = z;
          }
          l();
        }
      } catch (z) {
        if (z && E && typeof z.stack == "string") {
          for (var O = z.stack.split(`
`), $ = E.stack.split(`
`), M = O.length - 1, D = $.length - 1; M >= 1 && D >= 0 && O[M] !== $[D]; )
            D--;
          for (; M >= 1 && D >= 0; M--, D--)
            if (O[M] !== $[D]) {
              if (M !== 1 || D !== 1)
                do
                  if (M--, D--, D < 0 || O[M] !== $[D]) {
                    var G = `
` + O[M].replace(" at new ", " at ");
                    return l.displayName && G.includes("<anonymous>") && (G = G.replace("<anonymous>", l.displayName)), typeof l == "function" && nt.set(l, G), G;
                  }
                while (M >= 1 && D >= 0);
              break;
            }
        }
      } finally {
        bt = !1, gt.current = k, tr(), Error.prepareStackTrace = A;
      }
      var Pe = l ? l.displayName || l.name : "", _e = Pe ? tt(Pe) : "";
      return typeof l == "function" && nt.set(l, _e), _e;
    }
    function rr(l, p, b) {
      return qt(l, !1);
    }
    function ir(l) {
      var p = l.prototype;
      return !!(p && p.isReactComponent);
    }
    function rt(l, p, b) {
      if (l == null)
        return "";
      if (typeof l == "function")
        return qt(l, ir(l));
      if (typeof l == "string")
        return tt(l);
      switch (l) {
        case u:
          return tt("Suspense");
        case f:
          return tt("SuspenseList");
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case a:
            return rr(l.render);
          case h:
            return rt(l.type, p, b);
          case d: {
            var E = l, A = E._payload, k = E._init;
            try {
              return rt(k(A), p, b);
            } catch {
            }
          }
        }
      return "";
    }
    var He = Object.prototype.hasOwnProperty, Jt = {}, Kt = w.ReactDebugCurrentFrame;
    function it(l) {
      if (l) {
        var p = l._owner, b = rt(l.type, l._source, p ? p.type : null);
        Kt.setExtraStackFrame(b);
      } else
        Kt.setExtraStackFrame(null);
    }
    function or(l, p, b, E, A) {
      {
        var k = Function.call.bind(He);
        for (var C in l)
          if (k(l, C)) {
            var O = void 0;
            try {
              if (typeof l[C] != "function") {
                var $ = Error((E || "React class") + ": " + b + " type `" + C + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[C] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw $.name = "Invariant Violation", $;
              }
              O = l[C](p, C, E, b, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (M) {
              O = M;
            }
            O && !(O instanceof Error) && (it(A), _("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", E || "React class", b, C, typeof O), it(null)), O instanceof Error && !(O.message in Jt) && (Jt[O.message] = !0, it(A), _("Failed %s type: %s", b, O.message), it(null));
          }
      }
    }
    var sr = Array.isArray;
    function vt(l) {
      return sr(l);
    }
    function lr(l) {
      {
        var p = typeof Symbol == "function" && Symbol.toStringTag, b = p && l[Symbol.toStringTag] || l.constructor.name || "Object";
        return b;
      }
    }
    function cr(l) {
      try {
        return Xt(l), !1;
      } catch {
        return !0;
      }
    }
    function Xt(l) {
      return "" + l;
    }
    function Gt(l) {
      if (cr(l))
        return _("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", lr(l)), Xt(l);
    }
    var Ue = w.ReactCurrentOwner, ar = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Zt, Qt, yt;
    yt = {};
    function ur(l) {
      if (He.call(l, "ref")) {
        var p = Object.getOwnPropertyDescriptor(l, "ref").get;
        if (p && p.isReactWarning)
          return !1;
      }
      return l.ref !== void 0;
    }
    function fr(l) {
      if (He.call(l, "key")) {
        var p = Object.getOwnPropertyDescriptor(l, "key").get;
        if (p && p.isReactWarning)
          return !1;
      }
      return l.key !== void 0;
    }
    function dr(l, p) {
      if (typeof l.ref == "string" && Ue.current && p && Ue.current.stateNode !== p) {
        var b = j(Ue.current.type);
        yt[b] || (_('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', j(Ue.current.type), l.ref), yt[b] = !0);
      }
    }
    function hr(l, p) {
      {
        var b = function() {
          Zt || (Zt = !0, _("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", p));
        };
        b.isReactWarning = !0, Object.defineProperty(l, "key", {
          get: b,
          configurable: !0
        });
      }
    }
    function pr(l, p) {
      {
        var b = function() {
          Qt || (Qt = !0, _("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", p));
        };
        b.isReactWarning = !0, Object.defineProperty(l, "ref", {
          get: b,
          configurable: !0
        });
      }
    }
    var gr = function(l, p, b, E, A, k, C) {
      var O = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: l,
        key: p,
        ref: b,
        props: C,
        // Record the component responsible for creating this element.
        _owner: k
      };
      return O._store = {}, Object.defineProperty(O._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(O, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: E
      }), Object.defineProperty(O, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: A
      }), Object.freeze && (Object.freeze(O.props), Object.freeze(O)), O;
    };
    function mr(l, p, b, E, A) {
      {
        var k, C = {}, O = null, $ = null;
        b !== void 0 && (Gt(b), O = "" + b), fr(p) && (Gt(p.key), O = "" + p.key), ur(p) && ($ = p.ref, dr(p, A));
        for (k in p)
          He.call(p, k) && !ar.hasOwnProperty(k) && (C[k] = p[k]);
        if (l && l.defaultProps) {
          var M = l.defaultProps;
          for (k in M)
            C[k] === void 0 && (C[k] = M[k]);
        }
        if (O || $) {
          var D = typeof l == "function" ? l.displayName || l.name || "Unknown" : l;
          O && hr(C, D), $ && pr(C, D);
        }
        return gr(l, O, $, A, E, Ue.current, C);
      }
    }
    var _t = w.ReactCurrentOwner, en = w.ReactDebugCurrentFrame;
    function Ae(l) {
      if (l) {
        var p = l._owner, b = rt(l.type, l._source, p ? p.type : null);
        en.setExtraStackFrame(b);
      } else
        en.setExtraStackFrame(null);
    }
    var wt;
    wt = !1;
    function xt(l) {
      return typeof l == "object" && l !== null && l.$$typeof === t;
    }
    function tn() {
      {
        if (_t.current) {
          var l = j(_t.current.type);
          if (l)
            return `

Check the render method of \`` + l + "`.";
        }
        return "";
      }
    }
    function br(l) {
      return "";
    }
    var nn = {};
    function vr(l) {
      {
        var p = tn();
        if (!p) {
          var b = typeof l == "string" ? l : l.displayName || l.name;
          b && (p = `

Check the top-level render call using <` + b + ">.");
        }
        return p;
      }
    }
    function rn(l, p) {
      {
        if (!l._store || l._store.validated || l.key != null)
          return;
        l._store.validated = !0;
        var b = vr(p);
        if (nn[b])
          return;
        nn[b] = !0;
        var E = "";
        l && l._owner && l._owner !== _t.current && (E = " It was passed a child from " + j(l._owner.type) + "."), Ae(l), _('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', b, E), Ae(null);
      }
    }
    function on(l, p) {
      {
        if (typeof l != "object")
          return;
        if (vt(l))
          for (var b = 0; b < l.length; b++) {
            var E = l[b];
            xt(E) && rn(E, p);
          }
        else if (xt(l))
          l._store && (l._store.validated = !0);
        else if (l) {
          var A = S(l);
          if (typeof A == "function" && A !== l.entries)
            for (var k = A.call(l), C; !(C = k.next()).done; )
              xt(C.value) && rn(C.value, p);
        }
      }
    }
    function yr(l) {
      {
        var p = l.type;
        if (p == null || typeof p == "string")
          return;
        var b;
        if (typeof p == "function")
          b = p.propTypes;
        else if (typeof p == "object" && (p.$$typeof === a || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        p.$$typeof === h))
          b = p.propTypes;
        else
          return;
        if (b) {
          var E = j(p);
          or(b, l.props, "prop", E, l);
        } else if (p.PropTypes !== void 0 && !wt) {
          wt = !0;
          var A = j(p);
          _("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", A || "Unknown");
        }
        typeof p.getDefaultProps == "function" && !p.getDefaultProps.isReactClassApproved && _("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function _r(l) {
      {
        for (var p = Object.keys(l.props), b = 0; b < p.length; b++) {
          var E = p[b];
          if (E !== "children" && E !== "key") {
            Ae(l), _("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", E), Ae(null);
            break;
          }
        }
        l.ref !== null && (Ae(l), _("Invalid attribute `ref` supplied to `React.Fragment`."), Ae(null));
      }
    }
    var sn = {};
    function ln(l, p, b, E, A, k) {
      {
        var C = K(l);
        if (!C) {
          var O = "";
          (l === void 0 || typeof l == "object" && l !== null && Object.keys(l).length === 0) && (O += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var $ = br();
          $ ? O += $ : O += tn();
          var M;
          l === null ? M = "null" : vt(l) ? M = "array" : l !== void 0 && l.$$typeof === t ? (M = "<" + (j(l.type) || "Unknown") + " />", O = " Did you accidentally export a JSX literal instead of a component?") : M = typeof l, _("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", M, O);
        }
        var D = mr(l, p, b, A, k);
        if (D == null)
          return D;
        if (C) {
          var G = p.children;
          if (G !== void 0)
            if (E)
              if (vt(G)) {
                for (var Pe = 0; Pe < G.length; Pe++)
                  on(G[Pe], l);
                Object.freeze && Object.freeze(G);
              } else
                _("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              on(G, l);
        }
        if (He.call(p, "key")) {
          var _e = j(l), z = Object.keys(p).filter(function(Rr) {
            return Rr !== "key";
          }), Et = z.length > 0 ? "{key: someKey, " + z.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!sn[_e + Et]) {
            var Or = z.length > 0 ? "{" + z.join(": ..., ") + ": ...}" : "{}";
            _(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Et, _e, Or, _e), sn[_e + Et] = !0;
          }
        }
        return l === r ? _r(D) : yr(D), D;
      }
    }
    function wr(l, p, b) {
      return ln(l, p, b, !0);
    }
    function xr(l, p, b) {
      return ln(l, p, b, !1);
    }
    var Er = xr, Sr = wr;
    ze.Fragment = r, ze.jsx = Er, ze.jsxs = Sr;
  }()), ze;
}
process.env.NODE_ENV === "production" ? Ct.exports = Ar() : Ct.exports = Pr();
var kr = Ct.exports;
/*! shepherd.js 13.0.3 */
function Ir(e) {
  return e instanceof Element;
}
function Ge(e) {
  return e instanceof HTMLElement;
}
function pe(e) {
  return typeof e == "function";
}
function Je(e) {
  return typeof e == "string";
}
function N(e) {
  return e === void 0;
}
class Ft {
  /**
   * Adds an event listener for the given event string.
   *
   * @param {string} event
   * @param {Function} handler
   * @param ctx
   * @param {boolean} once
   * @returns
   */
  on(t, n, r, i = !1) {
    var s;
    return N(this.bindings) && (this.bindings = {}), N(this.bindings[t]) && (this.bindings[t] = []), (s = this.bindings[t]) == null || s.push({
      handler: n,
      ctx: r,
      once: i
    }), this;
  }
  /**
   * Adds an event listener that only fires once for the given event string.
   *
   * @param {string} event
   * @param {Function} handler
   * @param ctx
   * @returns
   */
  once(t, n, r) {
    return this.on(t, n, r, !0);
  }
  /**
   * Removes an event listener for the given event string.
   *
   * @param {string} event
   * @param {Function} handler
   * @returns
   */
  off(t, n) {
    if (N(this.bindings) || N(this.bindings[t]))
      return this;
    if (N(n))
      delete this.bindings[t];
    else {
      var r;
      (r = this.bindings[t]) == null || r.forEach((i, s) => {
        if (i.handler === n) {
          var o;
          (o = this.bindings[t]) == null || o.splice(s, 1);
        }
      });
    }
    return this;
  }
  /**
   * Triggers an event listener for the given event string.
   *
   * @param {string} event
   * @returns
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  trigger(t, ...n) {
    if (!N(this.bindings) && this.bindings[t]) {
      var r;
      (r = this.bindings[t]) == null || r.forEach((i, s) => {
        const {
          ctx: o,
          handler: c,
          once: a
        } = i, u = o || this;
        if (c.apply(u, n), a) {
          var f;
          (f = this.bindings[t]) == null || f.splice(s, 1);
        }
      });
    }
    return this;
  }
}
function V() {
  return V = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, V.apply(null, arguments);
}
function In(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
const be = {
  defaultMerge: Symbol("deepmerge-ts: default merge"),
  skip: Symbol("deepmerge-ts: skip")
};
be.defaultMerge;
function Mr(e, t) {
  return t;
}
function un(e) {
  return typeof e != "object" || e === null ? 0 : Array.isArray(e) ? 2 : Dr(e) ? 1 : e instanceof Set ? 3 : e instanceof Map ? 4 : 5;
}
function Fr(e) {
  const t = /* @__PURE__ */ new Set();
  for (const n of e)
    for (const r of [...Object.keys(n), ...Object.getOwnPropertySymbols(n)])
      t.add(r);
  return t;
}
function Lr(e, t) {
  return typeof e == "object" && Object.prototype.propertyIsEnumerable.call(e, t);
}
function Mn(e) {
  return {
    // eslint-disable-next-line functional/functional-parameters
    *[Symbol.iterator]() {
      for (const t of e)
        for (const n of t)
          yield n;
    }
  };
}
const fn = /* @__PURE__ */ new Set(["[object Object]", "[object Module]"]);
function Dr(e) {
  if (!fn.has(Object.prototype.toString.call(e)))
    return !1;
  const {
    constructor: t
  } = e;
  if (t === void 0)
    return !0;
  const n = t.prototype;
  return !(n === null || typeof n != "object" || !fn.has(Object.prototype.toString.call(n)) || !n.hasOwnProperty("isPrototypeOf"));
}
function jr(e, t, n) {
  const r = {};
  for (const i of Fr(e)) {
    const s = [];
    for (const a of e)
      Lr(a, i) && s.push(a[i]);
    if (s.length === 0)
      continue;
    const o = t.metaDataUpdater(n, {
      key: i,
      parents: e
    }), c = Ln(s, t, o);
    c !== be.skip && (i === "__proto__" ? Object.defineProperty(r, i, {
      value: c,
      configurable: !0,
      enumerable: !0,
      writable: !0
    }) : r[i] = c);
  }
  return r;
}
function Br(e) {
  return e.flat();
}
function Nr(e) {
  return new Set(Mn(e));
}
function Wr(e) {
  return new Map(Mn(e));
}
function Fn(e) {
  return e.at(-1);
}
var St = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  mergeArrays: Br,
  mergeMaps: Wr,
  mergeOthers: Fn,
  mergeRecords: jr,
  mergeSets: Nr
});
function Lt(...e) {
  return $r({})(...e);
}
function $r(e, t) {
  const n = Vr(e, r);
  function r(...i) {
    return Ln(i, n, t);
  }
  return r;
}
function Vr(e, t) {
  var n, r;
  return {
    defaultMergeFunctions: St,
    mergeFunctions: V({}, St, Object.fromEntries(Object.entries(e).filter(([i, s]) => Object.hasOwn(St, i)).map(([i, s]) => s === !1 ? [i, Fn] : [i, s]))),
    metaDataUpdater: (n = e.metaDataUpdater) != null ? n : Mr,
    deepmerge: t,
    useImplicitDefaultMerging: (r = e.enableImplicitDefaultMerging) != null ? r : !1,
    actions: be
  };
}
function Ln(e, t, n) {
  if (e.length === 0)
    return;
  if (e.length === 1)
    return Ot(e, t, n);
  const r = un(e[0]);
  if (r !== 0 && r !== 5) {
    for (let i = 1; i < e.length; i++)
      if (un(e[i]) !== r)
        return Ot(e, t, n);
  }
  switch (r) {
    case 1:
      return Hr(e, t, n);
    case 2:
      return Ur(e, t, n);
    case 3:
      return Yr(e, t, n);
    case 4:
      return zr(e, t, n);
    default:
      return Ot(e, t, n);
  }
}
function Hr(e, t, n) {
  const r = t.mergeFunctions.mergeRecords(e, t, n);
  return r === be.defaultMerge || t.useImplicitDefaultMerging && r === void 0 && t.mergeFunctions.mergeRecords !== t.defaultMergeFunctions.mergeRecords ? t.defaultMergeFunctions.mergeRecords(e, t, n) : r;
}
function Ur(e, t, n) {
  const r = t.mergeFunctions.mergeArrays(e, t, n);
  return r === be.defaultMerge || t.useImplicitDefaultMerging && r === void 0 && t.mergeFunctions.mergeArrays !== t.defaultMergeFunctions.mergeArrays ? t.defaultMergeFunctions.mergeArrays(e) : r;
}
function Yr(e, t, n) {
  const r = t.mergeFunctions.mergeSets(e, t, n);
  return r === be.defaultMerge || t.useImplicitDefaultMerging && r === void 0 && t.mergeFunctions.mergeSets !== t.defaultMergeFunctions.mergeSets ? t.defaultMergeFunctions.mergeSets(e) : r;
}
function zr(e, t, n) {
  const r = t.mergeFunctions.mergeMaps(e, t, n);
  return r === be.defaultMerge || t.useImplicitDefaultMerging && r === void 0 && t.mergeFunctions.mergeMaps !== t.defaultMergeFunctions.mergeMaps ? t.defaultMergeFunctions.mergeMaps(e) : r;
}
function Ot(e, t, n) {
  const r = t.mergeFunctions.mergeOthers(e, t, n);
  return r === be.defaultMerge || t.useImplicitDefaultMerging && r === void 0 && t.mergeFunctions.mergeOthers !== t.defaultMergeFunctions.mergeOthers ? t.defaultMergeFunctions.mergeOthers(e) : r;
}
function Dt(e) {
  const t = Object.getOwnPropertyNames(e.constructor.prototype);
  for (let n = 0; n < t.length; n++) {
    const r = t[n], i = e[r];
    r !== "constructor" && typeof i == "function" && (e[r] = i.bind(e));
  }
  return e;
}
function qr(e, t) {
  return (n) => {
    if (e.isOpen()) {
      const r = e.el && n.currentTarget === e.el;
      (!N(t) && n.currentTarget.matches(t) || r) && e.tour.next();
    }
  };
}
function Jr(e) {
  const {
    event: t,
    selector: n
  } = e.options.advanceOn || {};
  if (t) {
    const r = qr(e, n);
    let i = null;
    if (!N(n) && (i = document.querySelector(n), !i))
      return console.error(`No element was found for the selector supplied to advanceOn: ${n}`);
    i ? (i.addEventListener(t, r), e.on("destroy", () => i.removeEventListener(t, r))) : (document.body.addEventListener(t, r, !0), e.on("destroy", () => document.body.removeEventListener(t, r, !0)));
  } else
    return console.error("advanceOn was defined, but no event name was passed.");
}
class Kr {
  constructor(t) {
  }
}
class Xr {
  constructor(t, n) {
  }
}
function Dn(e) {
  return !Je(e) || e === "" ? "" : e.charAt(e.length - 1) !== "-" ? `${e}-` : e;
}
function Gr(e) {
  const t = e.options.attachTo || {}, n = Object.assign({}, t);
  if (pe(n.element) && (n.element = n.element.call(e)), Je(n.element)) {
    try {
      n.element = document.querySelector(n.element);
    } catch {
    }
    n.element || console.error(`The element for this Shepherd step was not found ${t.element}`);
  }
  return n;
}
function jn(e) {
  return e == null ? !0 : !e.element || !e.on;
}
function Bn() {
  let e = Date.now();
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
    const n = (e + Math.random() * 16) % 16 | 0;
    return e = Math.floor(e / 16), (t == "x" ? n : n & 3 | 8).toString(16);
  });
}
const De = Math.min, Ee = Math.max, lt = Math.round, ot = Math.floor, ge = (e) => ({
  x: e,
  y: e
}), Zr = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Qr = {
  start: "end",
  end: "start"
};
function At(e, t, n) {
  return Ee(e, De(t, n));
}
function je(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Re(e) {
  return e.split("-")[0];
}
function ft(e) {
  return e.split("-")[1];
}
function jt(e) {
  return e === "x" ? "y" : "x";
}
function Bt(e) {
  return e === "y" ? "height" : "width";
}
function Be(e) {
  return ["top", "bottom"].includes(Re(e)) ? "y" : "x";
}
function Nt(e) {
  return jt(Be(e));
}
function ei(e, t, n) {
  n === void 0 && (n = !1);
  const r = ft(e), i = Nt(e), s = Bt(i);
  let o = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (o = ct(o)), [o, ct(o)];
}
function ti(e) {
  const t = ct(e);
  return [Pt(e), t, Pt(t)];
}
function Pt(e) {
  return e.replace(/start|end/g, (t) => Qr[t]);
}
function ni(e, t, n) {
  const r = ["left", "right"], i = ["right", "left"], s = ["top", "bottom"], o = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? i : r : t ? r : i;
    case "left":
    case "right":
      return t ? s : o;
    default:
      return [];
  }
}
function ri(e, t, n, r) {
  const i = ft(e);
  let s = ni(Re(e), n === "start", r);
  return i && (s = s.map((o) => o + "-" + i), t && (s = s.concat(s.map(Pt)))), s;
}
function ct(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Zr[t]);
}
function ii(e) {
  return V({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, e);
}
function Nn(e) {
  return typeof e != "number" ? ii(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function at(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: i
  } = e;
  return {
    width: r,
    height: i,
    top: n,
    left: t,
    right: t + r,
    bottom: n + i,
    x: t,
    y: n
  };
}
const oi = ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "flipAlignment"], si = ["mainAxis", "crossAxis", "limiter"];
function dn(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const s = Be(t), o = Nt(t), c = Bt(o), a = Re(t), u = s === "y", f = r.x + r.width / 2 - i.width / 2, h = r.y + r.height / 2 - i.height / 2, d = r[c] / 2 - i[c] / 2;
  let g;
  switch (a) {
    case "top":
      g = {
        x: f,
        y: r.y - i.height
      };
      break;
    case "bottom":
      g = {
        x: f,
        y: r.y + r.height
      };
      break;
    case "right":
      g = {
        x: r.x + r.width,
        y: h
      };
      break;
    case "left":
      g = {
        x: r.x - i.width,
        y: h
      };
      break;
    default:
      g = {
        x: r.x,
        y: r.y
      };
  }
  switch (ft(t)) {
    case "start":
      g[o] -= d * (n && u ? -1 : 1);
      break;
    case "end":
      g[o] += d * (n && u ? -1 : 1);
      break;
  }
  return g;
}
const li = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: o
  } = n, c = s.filter(Boolean), a = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let u = await o.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: f,
    y: h
  } = dn(u, r, a), d = r, g = {}, v = 0;
  for (let x = 0; x < c.length; x++) {
    const {
      name: S,
      fn: w
    } = c[x], {
      x: _,
      y: R,
      data: y,
      reset: m
    } = await w({
      x: f,
      y: h,
      initialPlacement: r,
      placement: d,
      strategy: i,
      middlewareData: g,
      rects: u,
      platform: o,
      elements: {
        reference: e,
        floating: t
      }
    });
    f = _ ?? f, h = R ?? h, g = V({}, g, {
      [S]: V({}, g[S], y)
    }), m && v <= 50 && (v++, typeof m == "object" && (m.placement && (d = m.placement), m.rects && (u = m.rects === !0 ? await o.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : m.rects), {
      x: f,
      y: h
    } = dn(u, d, a)), x = -1);
  }
  return {
    x: f,
    y: h,
    placement: d,
    strategy: i,
    middlewareData: g
  };
};
async function Wn(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: s,
    rects: o,
    elements: c,
    strategy: a
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: h = "floating",
    altBoundary: d = !1,
    padding: g = 0
  } = je(t, e), v = Nn(g), S = c[d ? h === "floating" ? "reference" : "floating" : h], w = at(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(S))) == null || n ? S : S.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(c.floating)),
    boundary: u,
    rootBoundary: f,
    strategy: a
  })), _ = h === "floating" ? {
    x: r,
    y: i,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, R = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c.floating)), y = await (s.isElement == null ? void 0 : s.isElement(R)) ? await (s.getScale == null ? void 0 : s.getScale(R)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, m = at(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: _,
    offsetParent: R,
    strategy: a
  }) : _);
  return {
    top: (w.top - m.top + v.top) / y.y,
    bottom: (m.bottom - w.bottom + v.bottom) / y.y,
    left: (w.left - m.left + v.left) / y.x,
    right: (m.right - w.right + v.right) / y.x
  };
}
const ci = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: i,
      rects: s,
      platform: o,
      elements: c,
      middlewareData: a
    } = t, {
      element: u,
      padding: f = 0
    } = je(e, t) || {};
    if (u == null)
      return {};
    const h = Nn(f), d = {
      x: n,
      y: r
    }, g = Nt(i), v = Bt(g), x = await o.getDimensions(u), S = g === "y", w = S ? "top" : "left", _ = S ? "bottom" : "right", R = S ? "clientHeight" : "clientWidth", y = s.reference[v] + s.reference[g] - d[g] - s.floating[v], m = d[g] - s.reference[g], T = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(u));
    let B = T ? T[R] : 0;
    (!B || !await (o.isElement == null ? void 0 : o.isElement(T))) && (B = c.floating[R] || s.floating[v]);
    const ie = y / 2 - m / 2, H = B / 2 - x[v] / 2 - 1, K = De(h[w], H), U = De(h[_], H), W = K, j = B - x[v] - U, L = B / 2 - x[v] / 2 + ie, X = At(W, L, j), Y = !a.arrow && ft(i) != null && L !== X && s.reference[v] / 2 - (L < W ? K : U) - x[v] / 2 < 0, le = Y ? L < W ? L - W : L - j : 0;
    return {
      [g]: d[g] + le,
      data: V({
        [g]: X,
        centerOffset: L - X - le
      }, Y && {
        alignmentOffset: le
      }),
      reset: Y
    };
  }
}), ai = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(n) {
      var r, i;
      const {
        placement: s,
        middlewareData: o,
        rects: c,
        initialPlacement: a,
        platform: u,
        elements: f
      } = n, h = je(t, n), {
        mainAxis: d = !0,
        crossAxis: g = !0,
        fallbackPlacements: v,
        fallbackStrategy: x = "bestFit",
        fallbackAxisSideDirection: S = "none",
        flipAlignment: w = !0
      } = h, _ = In(h, oi);
      if ((r = o.arrow) != null && r.alignmentOffset)
        return {};
      const R = Re(s), y = Be(a), m = Re(a) === a, T = await (u.isRTL == null ? void 0 : u.isRTL(f.floating)), B = v || (m || !w ? [ct(a)] : ti(a)), ie = S !== "none";
      !v && ie && B.push(...ri(a, w, S, T));
      const H = [a, ...B], K = await Wn(n, _), U = [];
      let W = ((i = o.flip) == null ? void 0 : i.overflows) || [];
      if (d && U.push(K[R]), g) {
        const Y = ei(s, c, T);
        U.push(K[Y[0]], K[Y[1]]);
      }
      if (W = [...W, {
        placement: s,
        overflows: U
      }], !U.every((Y) => Y <= 0)) {
        var j, L;
        const Y = (((j = o.flip) == null ? void 0 : j.index) || 0) + 1, le = H[Y];
        if (le)
          return {
            data: {
              index: Y,
              overflows: W
            },
            reset: {
              placement: le
            }
          };
        let he = (L = W.filter((ce) => ce.overflows[0] <= 0).sort((ce, Q) => ce.overflows[1] - Q.overflows[1])[0]) == null ? void 0 : L.placement;
        if (!he)
          switch (x) {
            case "bestFit": {
              var X;
              const ce = (X = W.filter((Q) => {
                if (ie) {
                  const ee = Be(Q.placement);
                  return ee === y || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ee === "y";
                }
                return !0;
              }).map((Q) => [Q.placement, Q.overflows.filter((ee) => ee > 0).reduce((ee, et) => ee + et, 0)]).sort((Q, ee) => Q[1] - ee[1])[0]) == null ? void 0 : X[0];
              ce && (he = ce);
              break;
            }
            case "initialPlacement":
              he = a;
              break;
          }
        if (s !== he)
          return {
            reset: {
              placement: he
            }
          };
      }
      return {};
    }
  };
}, ui = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(n) {
      const {
        x: r,
        y: i,
        placement: s
      } = n, o = je(t, n), {
        mainAxis: c = !0,
        crossAxis: a = !1,
        limiter: u = {
          fn: (_) => {
            let {
              x: R,
              y
            } = _;
            return {
              x: R,
              y
            };
          }
        }
      } = o, f = In(o, si), h = {
        x: r,
        y: i
      }, d = await Wn(n, f), g = Be(Re(s)), v = jt(g);
      let x = h[v], S = h[g];
      if (c) {
        const _ = v === "y" ? "top" : "left", R = v === "y" ? "bottom" : "right", y = x + d[_], m = x - d[R];
        x = At(y, x, m);
      }
      if (a) {
        const _ = g === "y" ? "top" : "left", R = g === "y" ? "bottom" : "right", y = S + d[_], m = S - d[R];
        S = At(y, S, m);
      }
      const w = u.fn(V({}, n, {
        [v]: x,
        [g]: S
      }));
      return V({}, w, {
        data: {
          x: w.x - r,
          y: w.y - i
        }
      });
    }
  };
}, fi = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(n) {
      const {
        x: r,
        y: i,
        placement: s,
        rects: o,
        middlewareData: c
      } = n, {
        offset: a = 0,
        mainAxis: u = !0,
        crossAxis: f = !0
      } = je(t, n), h = {
        x: r,
        y: i
      }, d = Be(s), g = jt(d);
      let v = h[g], x = h[d];
      const S = je(a, n), w = typeof S == "number" ? {
        mainAxis: S,
        crossAxis: 0
      } : V({
        mainAxis: 0,
        crossAxis: 0
      }, S);
      if (u) {
        const y = g === "y" ? "height" : "width", m = o.reference[g] - o.floating[y] + w.mainAxis, T = o.reference[g] + o.reference[y] - w.mainAxis;
        v < m ? v = m : v > T && (v = T);
      }
      if (f) {
        var _, R;
        const y = g === "y" ? "width" : "height", m = ["top", "left"].includes(Re(s)), T = o.reference[d] - o.floating[y] + (m && ((_ = c.offset) == null ? void 0 : _[d]) || 0) + (m ? 0 : w.crossAxis), B = o.reference[d] + o.reference[y] + (m ? 0 : ((R = c.offset) == null ? void 0 : R[d]) || 0) - (m ? w.crossAxis : 0);
        x < T ? x = T : x > B && (x = B);
      }
      return {
        [g]: v,
        [d]: x
      };
    }
  };
};
function Ve(e) {
  return $n(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function q(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function ae(e) {
  var t;
  return (t = ($n(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function $n(e) {
  return e instanceof Node || e instanceof q(e).Node;
}
function te(e) {
  return e instanceof Element || e instanceof q(e).Element;
}
function oe(e) {
  return e instanceof HTMLElement || e instanceof q(e).HTMLElement;
}
function hn(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof q(e).ShadowRoot;
}
function Ze(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = ne(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i);
}
function di(e) {
  return ["table", "td", "th"].includes(Ve(e));
}
function dt(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function Wt(e) {
  const t = $t(), n = te(e) ? ne(e) : e;
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function hi(e) {
  let t = me(e);
  for (; oe(t) && !Ne(t); ) {
    if (Wt(t))
      return t;
    if (dt(t))
      return null;
    t = me(t);
  }
  return null;
}
function $t() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Ne(e) {
  return ["html", "body", "#document"].includes(Ve(e));
}
function ne(e) {
  return q(e).getComputedStyle(e);
}
function ht(e) {
  return te(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function me(e) {
  if (Ve(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    hn(e) && e.host || // Fallback.
    ae(e)
  );
  return hn(t) ? t.host : t;
}
function Vn(e) {
  const t = me(e);
  return Ne(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : oe(t) && Ze(t) ? t : Vn(t);
}
function Ke(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = Vn(e), s = i === ((r = e.ownerDocument) == null ? void 0 : r.body), o = q(i);
  return s ? t.concat(o, o.visualViewport || [], Ze(i) ? i : [], o.frameElement && n ? Ke(o.frameElement) : []) : t.concat(i, Ke(i, [], n));
}
function Hn(e) {
  const t = ne(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = oe(e), s = i ? e.offsetWidth : n, o = i ? e.offsetHeight : r, c = lt(n) !== s || lt(r) !== o;
  return c && (n = s, r = o), {
    width: n,
    height: r,
    $: c
  };
}
function Vt(e) {
  return te(e) ? e : e.contextElement;
}
function Fe(e) {
  const t = Vt(e);
  if (!oe(t))
    return ge(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: s
  } = Hn(t);
  let o = (s ? lt(n.width) : n.width) / r, c = (s ? lt(n.height) : n.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: o,
    y: c
  };
}
const pi = /* @__PURE__ */ ge(0);
function Un(e) {
  const t = q(e);
  return !$t() || !t.visualViewport ? pi : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function gi(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== q(e) ? !1 : t;
}
function Te(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), s = Vt(e);
  let o = ge(1);
  t && (r ? te(r) && (o = Fe(r)) : o = Fe(e));
  const c = gi(s, n, r) ? Un(s) : ge(0);
  let a = (i.left + c.x) / o.x, u = (i.top + c.y) / o.y, f = i.width / o.x, h = i.height / o.y;
  if (s) {
    const d = q(s), g = r && te(r) ? q(r) : r;
    let v = d, x = v.frameElement;
    for (; x && r && g !== v; ) {
      const S = Fe(x), w = x.getBoundingClientRect(), _ = ne(x), R = w.left + (x.clientLeft + parseFloat(_.paddingLeft)) * S.x, y = w.top + (x.clientTop + parseFloat(_.paddingTop)) * S.y;
      a *= S.x, u *= S.y, f *= S.x, h *= S.y, a += R, u += y, v = q(x), x = v.frameElement;
    }
  }
  return at({
    width: f,
    height: h,
    x: a,
    y: u
  });
}
function mi(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: i
  } = e;
  const s = i === "fixed", o = ae(r), c = t ? dt(t.floating) : !1;
  if (r === o || c && s)
    return n;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = ge(1);
  const f = ge(0), h = oe(r);
  if ((h || !h && !s) && ((Ve(r) !== "body" || Ze(o)) && (a = ht(r)), oe(r))) {
    const d = Te(r);
    u = Fe(r), f.x = d.x + r.clientLeft, f.y = d.y + r.clientTop;
  }
  return {
    width: n.width * u.x,
    height: n.height * u.y,
    x: n.x * u.x - a.scrollLeft * u.x + f.x,
    y: n.y * u.y - a.scrollTop * u.y + f.y
  };
}
function bi(e) {
  return Array.from(e.getClientRects());
}
function Yn(e) {
  return Te(ae(e)).left + ht(e).scrollLeft;
}
function vi(e) {
  const t = ae(e), n = ht(e), r = e.ownerDocument.body, i = Ee(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), s = Ee(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -n.scrollLeft + Yn(e);
  const c = -n.scrollTop;
  return ne(r).direction === "rtl" && (o += Ee(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: s,
    x: o,
    y: c
  };
}
function yi(e, t) {
  const n = q(e), r = ae(e), i = n.visualViewport;
  let s = r.clientWidth, o = r.clientHeight, c = 0, a = 0;
  if (i) {
    s = i.width, o = i.height;
    const u = $t();
    (!u || u && t === "fixed") && (c = i.offsetLeft, a = i.offsetTop);
  }
  return {
    width: s,
    height: o,
    x: c,
    y: a
  };
}
function _i(e, t) {
  const n = Te(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, s = oe(e) ? Fe(e) : ge(1), o = e.clientWidth * s.x, c = e.clientHeight * s.y, a = i * s.x, u = r * s.y;
  return {
    width: o,
    height: c,
    x: a,
    y: u
  };
}
function pn(e, t, n) {
  let r;
  if (t === "viewport")
    r = yi(e, n);
  else if (t === "document")
    r = vi(ae(e));
  else if (te(t))
    r = _i(t, n);
  else {
    const i = Un(e);
    r = V({}, t, {
      x: t.x - i.x,
      y: t.y - i.y
    });
  }
  return at(r);
}
function zn(e, t) {
  const n = me(e);
  return n === t || !te(n) || Ne(n) ? !1 : ne(n).position === "fixed" || zn(n, t);
}
function wi(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = Ke(e, [], !1).filter((c) => te(c) && Ve(c) !== "body"), i = null;
  const s = ne(e).position === "fixed";
  let o = s ? me(e) : e;
  for (; te(o) && !Ne(o); ) {
    const c = ne(o), a = Wt(o);
    !a && c.position === "fixed" && (i = null), (s ? !a && !i : !a && c.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || Ze(o) && !a && zn(e, o)) ? r = r.filter((f) => f !== o) : i = c, o = me(o);
  }
  return t.set(e, r), r;
}
function xi(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const o = [...n === "clippingAncestors" ? dt(t) ? [] : wi(t, this._c) : [].concat(n), r], c = o[0], a = o.reduce((u, f) => {
    const h = pn(t, f, i);
    return u.top = Ee(h.top, u.top), u.right = De(h.right, u.right), u.bottom = De(h.bottom, u.bottom), u.left = Ee(h.left, u.left), u;
  }, pn(t, c, i));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function Ei(e) {
  const {
    width: t,
    height: n
  } = Hn(e);
  return {
    width: t,
    height: n
  };
}
function Si(e, t, n) {
  const r = oe(t), i = ae(t), s = n === "fixed", o = Te(e, !0, s, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = ge(0);
  if (r || !r && !s)
    if ((Ve(t) !== "body" || Ze(i)) && (c = ht(t)), r) {
      const h = Te(t, !0, s, t);
      a.x = h.x + t.clientLeft, a.y = h.y + t.clientTop;
    } else i && (a.x = Yn(i));
  const u = o.left + c.scrollLeft - a.x, f = o.top + c.scrollTop - a.y;
  return {
    x: u,
    y: f,
    width: o.width,
    height: o.height
  };
}
function Rt(e) {
  return ne(e).position === "static";
}
function gn(e, t) {
  return !oe(e) || ne(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function qn(e, t) {
  const n = q(e);
  if (dt(e))
    return n;
  if (!oe(e)) {
    let i = me(e);
    for (; i && !Ne(i); ) {
      if (te(i) && !Rt(i))
        return i;
      i = me(i);
    }
    return n;
  }
  let r = gn(e, t);
  for (; r && di(r) && Rt(r); )
    r = gn(r, t);
  return r && Ne(r) && Rt(r) && !Wt(r) ? n : r || hi(e) || n;
}
const Oi = async function(t) {
  const n = this.getOffsetParent || qn, r = this.getDimensions, i = await r(t.floating);
  return {
    reference: Si(t.reference, await n(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
};
function Ri(e) {
  return ne(e).direction === "rtl";
}
const Ti = {
  convertOffsetParentRelativeRectToViewportRelativeRect: mi,
  getDocumentElement: ae,
  getClippingRect: xi,
  getOffsetParent: qn,
  getElementRects: Oi,
  getClientRects: bi,
  getDimensions: Ei,
  getScale: Fe,
  isElement: te,
  isRTL: Ri
};
function Ci(e, t) {
  let n = null, r;
  const i = ae(e);
  function s() {
    var c;
    clearTimeout(r), (c = n) == null || c.disconnect(), n = null;
  }
  function o(c, a) {
    c === void 0 && (c = !1), a === void 0 && (a = 1), s();
    const {
      left: u,
      top: f,
      width: h,
      height: d
    } = e.getBoundingClientRect();
    if (c || t(), !h || !d)
      return;
    const g = ot(f), v = ot(i.clientWidth - (u + h)), x = ot(i.clientHeight - (f + d)), S = ot(u), _ = {
      rootMargin: -g + "px " + -v + "px " + -x + "px " + -S + "px",
      threshold: Ee(0, De(1, a)) || 1
    };
    let R = !0;
    function y(m) {
      const T = m[0].intersectionRatio;
      if (T !== a) {
        if (!R)
          return o();
        T ? o(!1, T) : r = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      R = !1;
    }
    try {
      n = new IntersectionObserver(y, V({}, _, {
        // Handle <iframe>s
        root: i.ownerDocument
      }));
    } catch {
      n = new IntersectionObserver(y, _);
    }
    n.observe(e);
  }
  return o(!0), s;
}
function Ai(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: s = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: a = !1
  } = r, u = Vt(e), f = i || s ? [...u ? Ke(u) : [], ...Ke(t)] : [];
  f.forEach((w) => {
    i && w.addEventListener("scroll", n, {
      passive: !0
    }), s && w.addEventListener("resize", n);
  });
  const h = u && c ? Ci(u, n) : null;
  let d = -1, g = null;
  o && (g = new ResizeObserver((w) => {
    let [_] = w;
    _ && _.target === u && g && (g.unobserve(t), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
      var R;
      (R = g) == null || R.observe(t);
    })), n();
  }), u && !a && g.observe(u), g.observe(t));
  let v, x = a ? Te(e) : null;
  a && S();
  function S() {
    const w = Te(e);
    x && (w.x !== x.x || w.y !== x.y || w.width !== x.width || w.height !== x.height) && n(), x = w, v = requestAnimationFrame(S);
  }
  return n(), () => {
    var w;
    f.forEach((_) => {
      i && _.removeEventListener("scroll", n), s && _.removeEventListener("resize", n);
    }), h == null || h(), (w = g) == null || w.disconnect(), g = null, a && cancelAnimationFrame(v);
  };
}
const Pi = ui, ki = ai, Ii = ci, Mi = fi, Fi = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = V({
    platform: Ti
  }, n), s = V({}, i.platform, {
    _c: r
  });
  return li(e, t, V({}, i, {
    platform: s
  }));
};
function Li(e) {
  e.cleanup && e.cleanup();
  const t = e._getResolvedAttachToOptions();
  let n = t.element;
  const r = $i(t, e), i = jn(t);
  return i && (n = document.body, e.shepherdElementComponent.getElement().classList.add("shepherd-centered")), e.cleanup = Ai(n, e.el, () => {
    if (!e.el) {
      e.cleanup == null || e.cleanup();
      return;
    }
    Bi(n, e, r, i);
  }), e.target = t.element, r;
}
function Di(e, t) {
  return {
    floatingUIOptions: Lt(e.floatingUIOptions || {}, t.floatingUIOptions || {})
  };
}
function ji(e) {
  e.cleanup && e.cleanup(), e.cleanup = null;
}
function Bi(e, t, n, r) {
  return Fi(e, t.el, n).then(Ni(t, r)).then((i) => new Promise((s) => {
    setTimeout(() => s(i), 300);
  })).then((i) => {
    i != null && i.el && i.el.focus({
      preventScroll: !0
    });
  });
}
function Ni(e, t) {
  return ({
    x: n,
    y: r,
    placement: i,
    middlewareData: s
  }) => (e.el && (t ? Object.assign(e.el.style, {
    position: "fixed",
    left: "50%",
    top: "50%",
    transform: "translate(-50%, -50%)"
  }) : Object.assign(e.el.style, {
    position: "absolute",
    left: `${n}px`,
    top: `${r}px`
  }), e.el.dataset.popperPlacement = i, Wi(e.el, s)), e);
}
function Wi(e, t) {
  const n = e.querySelector(".shepherd-arrow");
  if (Ge(n) && t.arrow) {
    const {
      x: r,
      y: i
    } = t.arrow;
    Object.assign(n.style, {
      left: r != null ? `${r}px` : "",
      top: i != null ? `${i}px` : ""
    });
  }
}
function $i(e, t) {
  const n = {
    strategy: "absolute"
  };
  n.middleware = [];
  const r = Vi(t);
  if (!jn(e)) {
    if (n.middleware.push(
      ki(),
      // Replicate PopperJS default behavior.
      Pi({
        limiter: Mi(),
        crossAxis: !0
      })
    ), r) {
      var s, o;
      const c = (e == null || (s = e.on) == null ? void 0 : s.includes("-start")) || (e == null || (o = e.on) == null ? void 0 : o.includes("-end"));
      n.middleware.push(Ii({
        element: r,
        padding: c ? 4 : 0
      }));
    }
    n.placement = e.on;
  }
  return Lt(t.options.floatingUIOptions || {}, n);
}
function Vi(e) {
  return e.options.arrow && e.el ? e.el.querySelector(".shepherd-arrow") : !1;
}
function J() {
}
function Hi(e, t) {
  for (const n in t) e[n] = t[n];
  return (
    /** @type {T & S} */
    e
  );
}
function Jn(e) {
  return e();
}
function mn() {
  return /* @__PURE__ */ Object.create(null);
}
function Qe(e) {
  e.forEach(Jn);
}
function Ht(e) {
  return typeof e == "function";
}
function ue(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
function Ui(e) {
  return Object.keys(e).length === 0;
}
function We(e, t) {
  e.appendChild(t);
}
function re(e, t, n) {
  e.insertBefore(t, n || null);
}
function Z(e) {
  e.parentNode && e.parentNode.removeChild(e);
}
function Yi(e, t) {
  for (let n = 0; n < e.length; n += 1)
    e[n] && e[n].d(t);
}
function se(e) {
  return document.createElement(e);
}
function bn(e) {
  return document.createElementNS("http://www.w3.org/2000/svg", e);
}
function Kn(e) {
  return document.createTextNode(e);
}
function ut() {
  return Kn(" ");
}
function zi() {
  return Kn("");
}
function pt(e, t, n, r) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n, r);
}
function I(e, t, n) {
  n == null ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n);
}
const qi = ["width", "height"];
function vn(e, t) {
  const n = Object.getOwnPropertyDescriptors(e.__proto__);
  for (const r in t)
    t[r] == null ? e.removeAttribute(r) : r === "style" ? e.style.cssText = t[r] : r === "__value" ? e.value = e[r] = t[r] : n[r] && n[r].set && qi.indexOf(r) === -1 ? e[r] = t[r] : I(e, r, t[r]);
}
function Ji(e) {
  return Array.from(e.childNodes);
}
function ke(e, t, n) {
  e.classList.toggle(t, !!n);
}
let Xe;
function qe(e) {
  Xe = e;
}
function Xn() {
  if (!Xe) throw new Error("Function called outside component initialization");
  return Xe;
}
function Ki(e) {
  Xn().$$.on_mount.push(e);
}
function Ut(e) {
  Xn().$$.after_update.push(e);
}
const Me = [], $e = [];
let Le = [];
const yn = [], Xi = /* @__PURE__ */ Promise.resolve();
let kt = !1;
function Gi() {
  kt || (kt = !0, Xi.then(Gn));
}
function It(e) {
  Le.push(e);
}
const Tt = /* @__PURE__ */ new Set();
let Ie = 0;
function Gn() {
  if (Ie !== 0)
    return;
  const e = Xe;
  do {
    try {
      for (; Ie < Me.length; ) {
        const t = Me[Ie];
        Ie++, qe(t), Zi(t.$$);
      }
    } catch (t) {
      throw Me.length = 0, Ie = 0, t;
    }
    for (qe(null), Me.length = 0, Ie = 0; $e.length; ) $e.pop()();
    for (let t = 0; t < Le.length; t += 1) {
      const n = Le[t];
      Tt.has(n) || (Tt.add(n), n());
    }
    Le.length = 0;
  } while (Me.length);
  for (; yn.length; )
    yn.pop()();
  kt = !1, Tt.clear(), qe(e);
}
function Zi(e) {
  if (e.fragment !== null) {
    e.update(), Qe(e.before_update);
    const t = e.dirty;
    e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(It);
  }
}
function Qi(e) {
  const t = [], n = [];
  Le.forEach((r) => e.indexOf(r) === -1 ? t.push(r) : n.push(r)), n.forEach((r) => r()), Le = t;
}
const st = /* @__PURE__ */ new Set();
let we;
function Se() {
  we = {
    r: 0,
    c: [],
    p: we
    // parent group
  };
}
function Oe() {
  we.r || Qe(we.c), we = we.p;
}
function P(e, t) {
  e && e.i && (st.delete(e), e.i(t));
}
function F(e, t, n, r) {
  if (e && e.o) {
    if (st.has(e)) return;
    st.add(e), we.c.push(() => {
      st.delete(e), r && (n && e.d(1), r());
    }), e.o(t);
  } else r && r();
}
function _n(e) {
  return (e == null ? void 0 : e.length) !== void 0 ? e : Array.from(e);
}
function eo(e, t) {
  const n = {}, r = {}, i = {
    $$scope: 1
  };
  let s = e.length;
  for (; s--; ) {
    const o = e[s], c = t[s];
    if (c) {
      for (const a in o)
        a in c || (r[a] = 1);
      for (const a in c)
        i[a] || (n[a] = c[a], i[a] = 1);
      e[s] = c;
    } else
      for (const a in o)
        i[a] = 1;
  }
  for (const o in r)
    o in n || (n[o] = void 0);
  return n;
}
function Ce(e) {
  e && e.c();
}
function ve(e, t, n) {
  const {
    fragment: r,
    after_update: i
  } = e.$$;
  r && r.m(t, n), It(() => {
    const s = e.$$.on_mount.map(Jn).filter(Ht);
    e.$$.on_destroy ? e.$$.on_destroy.push(...s) : Qe(s), e.$$.on_mount = [];
  }), i.forEach(It);
}
function ye(e, t) {
  const n = e.$$;
  n.fragment !== null && (Qi(n.after_update), Qe(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []);
}
function to(e, t) {
  e.$$.dirty[0] === -1 && (Me.push(e), Gi(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31;
}
function fe(e, t, n, r, i, s, o = null, c = [-1]) {
  const a = Xe;
  qe(e);
  const u = e.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: s,
    update: J,
    not_equal: i,
    bound: mn(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(t.context || (a ? a.$$.context : [])),
    // everything else
    callbacks: mn(),
    dirty: c,
    skip_bound: !1,
    root: t.target || a.$$.root
  };
  o && o(u.root);
  let f = !1;
  if (u.ctx = n ? n(e, t.props || {}, (h, d, ...g) => {
    const v = g.length ? g[0] : d;
    return u.ctx && i(u.ctx[h], u.ctx[h] = v) && (!u.skip_bound && u.bound[h] && u.bound[h](v), f && to(e, h)), d;
  }) : [], u.update(), f = !0, Qe(u.before_update), u.fragment = r ? r(u.ctx) : !1, t.target) {
    if (t.hydrate) {
      const h = Ji(t.target);
      u.fragment && u.fragment.l(h), h.forEach(Z);
    } else
      u.fragment && u.fragment.c();
    t.intro && P(e.$$.fragment), ve(e, t.target, t.anchor), Gn();
  }
  qe(a);
}
class de {
  constructor() {
    this.$$ = void 0, this.$$set = void 0;
  }
  /** @returns {void} */
  $destroy() {
    ye(this, 1), this.$destroy = J;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(t, n) {
    if (!Ht(n))
      return J;
    const r = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
    return r.push(n), () => {
      const i = r.indexOf(n);
      i !== -1 && r.splice(i, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(t) {
    this.$$set && !Ui(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);
  }
}
const no = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = {
  v: /* @__PURE__ */ new Set()
})).v.add(no);
function ro(e) {
  let t, n, r, i, s;
  return {
    c() {
      t = se("button"), I(t, "aria-label", n = /*label*/
      e[3] ? (
        /*label*/
        e[3]
      ) : null), I(t, "class", r = `${/*classes*/
      e[1] || ""} shepherd-button ${/*secondary*/
      e[4] ? "shepherd-button-secondary" : ""}`), t.disabled = /*disabled*/
      e[2], I(t, "tabindex", "0"), I(t, "type", "button");
    },
    m(o, c) {
      re(o, t, c), t.innerHTML = /*text*/
      e[5], i || (s = pt(t, "click", function() {
        Ht(
          /*action*/
          e[0]
        ) && e[0].apply(this, arguments);
      }), i = !0);
    },
    p(o, [c]) {
      e = o, c & /*text*/
      32 && (t.innerHTML = /*text*/
      e[5]), c & /*label*/
      8 && n !== (n = /*label*/
      e[3] ? (
        /*label*/
        e[3]
      ) : null) && I(t, "aria-label", n), c & /*classes, secondary*/
      18 && r !== (r = `${/*classes*/
      e[1] || ""} shepherd-button ${/*secondary*/
      e[4] ? "shepherd-button-secondary" : ""}`) && I(t, "class", r), c & /*disabled*/
      4 && (t.disabled = /*disabled*/
      e[2]);
    },
    i: J,
    o: J,
    d(o) {
      o && Z(t), i = !1, s();
    }
  };
}
function io(e, t, n) {
  let {
    config: r,
    step: i
  } = t, s, o, c, a, u, f;
  function h(d) {
    return pe(d) ? d = d.call(i) : d;
  }
  return e.$$set = (d) => {
    "config" in d && n(6, r = d.config), "step" in d && n(7, i = d.step);
  }, e.$$.update = () => {
    e.$$.dirty & /*config, step*/
    192 && (n(0, s = r.action ? r.action.bind(i.tour) : null), n(1, o = r.classes), n(2, c = r.disabled ? h(r.disabled) : !1), n(3, a = r.label ? h(r.label) : null), n(4, u = r.secondary), n(5, f = r.text ? h(r.text) : null));
  }, [s, o, c, a, u, f, r, i];
}
class oo extends de {
  constructor(t) {
    super(), fe(this, t, io, ro, ue, {
      config: 6,
      step: 7
    });
  }
}
function wn(e, t, n) {
  const r = e.slice();
  return r[2] = t[n], r;
}
function xn(e) {
  let t, n, r = _n(
    /*buttons*/
    e[1]
  ), i = [];
  for (let o = 0; o < r.length; o += 1)
    i[o] = En(wn(e, r, o));
  const s = (o) => F(i[o], 1, 1, () => {
    i[o] = null;
  });
  return {
    c() {
      for (let o = 0; o < i.length; o += 1)
        i[o].c();
      t = zi();
    },
    m(o, c) {
      for (let a = 0; a < i.length; a += 1)
        i[a] && i[a].m(o, c);
      re(o, t, c), n = !0;
    },
    p(o, c) {
      if (c & /*buttons, step*/
      3) {
        r = _n(
          /*buttons*/
          o[1]
        );
        let a;
        for (a = 0; a < r.length; a += 1) {
          const u = wn(o, r, a);
          i[a] ? (i[a].p(u, c), P(i[a], 1)) : (i[a] = En(u), i[a].c(), P(i[a], 1), i[a].m(t.parentNode, t));
        }
        for (Se(), a = r.length; a < i.length; a += 1)
          s(a);
        Oe();
      }
    },
    i(o) {
      if (!n) {
        for (let c = 0; c < r.length; c += 1)
          P(i[c]);
        n = !0;
      }
    },
    o(o) {
      i = i.filter(Boolean);
      for (let c = 0; c < i.length; c += 1)
        F(i[c]);
      n = !1;
    },
    d(o) {
      o && Z(t), Yi(i, o);
    }
  };
}
function En(e) {
  let t, n;
  return t = new oo({
    props: {
      config: (
        /*config*/
        e[2]
      ),
      step: (
        /*step*/
        e[0]
      )
    }
  }), {
    c() {
      Ce(t.$$.fragment);
    },
    m(r, i) {
      ve(t, r, i), n = !0;
    },
    p(r, i) {
      const s = {};
      i & /*buttons*/
      2 && (s.config = /*config*/
      r[2]), i & /*step*/
      1 && (s.step = /*step*/
      r[0]), t.$set(s);
    },
    i(r) {
      n || (P(t.$$.fragment, r), n = !0);
    },
    o(r) {
      F(t.$$.fragment, r), n = !1;
    },
    d(r) {
      ye(t, r);
    }
  };
}
function so(e) {
  let t, n, r = (
    /*buttons*/
    e[1] && xn(e)
  );
  return {
    c() {
      t = se("footer"), r && r.c(), I(t, "class", "shepherd-footer");
    },
    m(i, s) {
      re(i, t, s), r && r.m(t, null), n = !0;
    },
    p(i, [s]) {
      /*buttons*/
      i[1] ? r ? (r.p(i, s), s & /*buttons*/
      2 && P(r, 1)) : (r = xn(i), r.c(), P(r, 1), r.m(t, null)) : r && (Se(), F(r, 1, 1, () => {
        r = null;
      }), Oe());
    },
    i(i) {
      n || (P(r), n = !0);
    },
    o(i) {
      F(r), n = !1;
    },
    d(i) {
      i && Z(t), r && r.d();
    }
  };
}
function lo(e, t, n) {
  let r, {
    step: i
  } = t;
  return e.$$set = (s) => {
    "step" in s && n(0, i = s.step);
  }, e.$$.update = () => {
    e.$$.dirty & /*step*/
    1 && n(1, r = i.options.buttons);
  }, [i, r];
}
class co extends de {
  constructor(t) {
    super(), fe(this, t, lo, so, ue, {
      step: 0
    });
  }
}
function ao(e) {
  let t, n, r, i, s;
  return {
    c() {
      t = se("button"), n = se("span"), n.textContent = "", I(n, "aria-hidden", "true"), I(t, "aria-label", r = /*cancelIcon*/
      e[0].label ? (
        /*cancelIcon*/
        e[0].label
      ) : "Close Tour"), I(t, "class", "shepherd-cancel-icon"), I(t, "type", "button");
    },
    m(o, c) {
      re(o, t, c), We(t, n), i || (s = pt(
        t,
        "click",
        /*handleCancelClick*/
        e[1]
      ), i = !0);
    },
    p(o, [c]) {
      c & /*cancelIcon*/
      1 && r !== (r = /*cancelIcon*/
      o[0].label ? (
        /*cancelIcon*/
        o[0].label
      ) : "Close Tour") && I(t, "aria-label", r);
    },
    i: J,
    o: J,
    d(o) {
      o && Z(t), i = !1, s();
    }
  };
}
function uo(e, t, n) {
  let {
    cancelIcon: r,
    step: i
  } = t;
  const s = (o) => {
    o.preventDefault(), i.cancel();
  };
  return e.$$set = (o) => {
    "cancelIcon" in o && n(0, r = o.cancelIcon), "step" in o && n(2, i = o.step);
  }, [r, s, i];
}
class fo extends de {
  constructor(t) {
    super(), fe(this, t, uo, ao, ue, {
      cancelIcon: 0,
      step: 2
    });
  }
}
function ho(e) {
  let t;
  return {
    c() {
      t = se("h3"), I(
        t,
        "id",
        /*labelId*/
        e[1]
      ), I(t, "class", "shepherd-title");
    },
    m(n, r) {
      re(n, t, r), e[3](t);
    },
    p(n, [r]) {
      r & /*labelId*/
      2 && I(
        t,
        "id",
        /*labelId*/
        n[1]
      );
    },
    i: J,
    o: J,
    d(n) {
      n && Z(t), e[3](null);
    }
  };
}
function po(e, t, n) {
  let {
    labelId: r,
    element: i,
    title: s
  } = t;
  Ut(() => {
    pe(s) && n(2, s = s()), n(0, i.innerHTML = s, i);
  });
  function o(c) {
    $e[c ? "unshift" : "push"](() => {
      i = c, n(0, i);
    });
  }
  return e.$$set = (c) => {
    "labelId" in c && n(1, r = c.labelId), "element" in c && n(0, i = c.element), "title" in c && n(2, s = c.title);
  }, [i, r, s, o];
}
class go extends de {
  constructor(t) {
    super(), fe(this, t, po, ho, ue, {
      labelId: 1,
      element: 0,
      title: 2
    });
  }
}
function Sn(e) {
  let t, n;
  return t = new go({
    props: {
      labelId: (
        /*labelId*/
        e[0]
      ),
      title: (
        /*title*/
        e[2]
      )
    }
  }), {
    c() {
      Ce(t.$$.fragment);
    },
    m(r, i) {
      ve(t, r, i), n = !0;
    },
    p(r, i) {
      const s = {};
      i & /*labelId*/
      1 && (s.labelId = /*labelId*/
      r[0]), i & /*title*/
      4 && (s.title = /*title*/
      r[2]), t.$set(s);
    },
    i(r) {
      n || (P(t.$$.fragment, r), n = !0);
    },
    o(r) {
      F(t.$$.fragment, r), n = !1;
    },
    d(r) {
      ye(t, r);
    }
  };
}
function On(e) {
  let t, n;
  return t = new fo({
    props: {
      cancelIcon: (
        /*cancelIcon*/
        e[3]
      ),
      step: (
        /*step*/
        e[1]
      )
    }
  }), {
    c() {
      Ce(t.$$.fragment);
    },
    m(r, i) {
      ve(t, r, i), n = !0;
    },
    p(r, i) {
      const s = {};
      i & /*cancelIcon*/
      8 && (s.cancelIcon = /*cancelIcon*/
      r[3]), i & /*step*/
      2 && (s.step = /*step*/
      r[1]), t.$set(s);
    },
    i(r) {
      n || (P(t.$$.fragment, r), n = !0);
    },
    o(r) {
      F(t.$$.fragment, r), n = !1;
    },
    d(r) {
      ye(t, r);
    }
  };
}
function mo(e) {
  let t, n, r, i = (
    /*title*/
    e[2] && Sn(e)
  ), s = (
    /*cancelIcon*/
    e[3] && /*cancelIcon*/
    e[3].enabled && On(e)
  );
  return {
    c() {
      t = se("header"), i && i.c(), n = ut(), s && s.c(), I(t, "class", "shepherd-header");
    },
    m(o, c) {
      re(o, t, c), i && i.m(t, null), We(t, n), s && s.m(t, null), r = !0;
    },
    p(o, [c]) {
      /*title*/
      o[2] ? i ? (i.p(o, c), c & /*title*/
      4 && P(i, 1)) : (i = Sn(o), i.c(), P(i, 1), i.m(t, n)) : i && (Se(), F(i, 1, 1, () => {
        i = null;
      }), Oe()), /*cancelIcon*/
      o[3] && /*cancelIcon*/
      o[3].enabled ? s ? (s.p(o, c), c & /*cancelIcon*/
      8 && P(s, 1)) : (s = On(o), s.c(), P(s, 1), s.m(t, null)) : s && (Se(), F(s, 1, 1, () => {
        s = null;
      }), Oe());
    },
    i(o) {
      r || (P(i), P(s), r = !0);
    },
    o(o) {
      F(i), F(s), r = !1;
    },
    d(o) {
      o && Z(t), i && i.d(), s && s.d();
    }
  };
}
function bo(e, t, n) {
  let {
    labelId: r,
    step: i
  } = t, s, o;
  return e.$$set = (c) => {
    "labelId" in c && n(0, r = c.labelId), "step" in c && n(1, i = c.step);
  }, e.$$.update = () => {
    e.$$.dirty & /*step*/
    2 && (n(2, s = i.options.title), n(3, o = i.options.cancelIcon));
  }, [r, i, s, o];
}
class vo extends de {
  constructor(t) {
    super(), fe(this, t, bo, mo, ue, {
      labelId: 0,
      step: 1
    });
  }
}
function yo(e) {
  let t;
  return {
    c() {
      t = se("div"), I(t, "class", "shepherd-text"), I(
        t,
        "id",
        /*descriptionId*/
        e[1]
      );
    },
    m(n, r) {
      re(n, t, r), e[3](t);
    },
    p(n, [r]) {
      r & /*descriptionId*/
      2 && I(
        t,
        "id",
        /*descriptionId*/
        n[1]
      );
    },
    i: J,
    o: J,
    d(n) {
      n && Z(t), e[3](null);
    }
  };
}
function _o(e, t, n) {
  let {
    descriptionId: r,
    element: i,
    step: s
  } = t;
  Ut(() => {
    let {
      text: c
    } = s.options;
    pe(c) && (c = c.call(s)), Ge(c) ? i.appendChild(c) : n(0, i.innerHTML = c, i);
  });
  function o(c) {
    $e[c ? "unshift" : "push"](() => {
      i = c, n(0, i);
    });
  }
  return e.$$set = (c) => {
    "descriptionId" in c && n(1, r = c.descriptionId), "element" in c && n(0, i = c.element), "step" in c && n(2, s = c.step);
  }, [i, r, s, o];
}
class wo extends de {
  constructor(t) {
    super(), fe(this, t, _o, yo, ue, {
      descriptionId: 1,
      element: 0,
      step: 2
    });
  }
}
function Rn(e) {
  let t, n;
  return t = new vo({
    props: {
      labelId: (
        /*labelId*/
        e[1]
      ),
      step: (
        /*step*/
        e[2]
      )
    }
  }), {
    c() {
      Ce(t.$$.fragment);
    },
    m(r, i) {
      ve(t, r, i), n = !0;
    },
    p(r, i) {
      const s = {};
      i & /*labelId*/
      2 && (s.labelId = /*labelId*/
      r[1]), i & /*step*/
      4 && (s.step = /*step*/
      r[2]), t.$set(s);
    },
    i(r) {
      n || (P(t.$$.fragment, r), n = !0);
    },
    o(r) {
      F(t.$$.fragment, r), n = !1;
    },
    d(r) {
      ye(t, r);
    }
  };
}
function Tn(e) {
  let t, n;
  return t = new wo({
    props: {
      descriptionId: (
        /*descriptionId*/
        e[0]
      ),
      step: (
        /*step*/
        e[2]
      )
    }
  }), {
    c() {
      Ce(t.$$.fragment);
    },
    m(r, i) {
      ve(t, r, i), n = !0;
    },
    p(r, i) {
      const s = {};
      i & /*descriptionId*/
      1 && (s.descriptionId = /*descriptionId*/
      r[0]), i & /*step*/
      4 && (s.step = /*step*/
      r[2]), t.$set(s);
    },
    i(r) {
      n || (P(t.$$.fragment, r), n = !0);
    },
    o(r) {
      F(t.$$.fragment, r), n = !1;
    },
    d(r) {
      ye(t, r);
    }
  };
}
function Cn(e) {
  let t, n;
  return t = new co({
    props: {
      step: (
        /*step*/
        e[2]
      )
    }
  }), {
    c() {
      Ce(t.$$.fragment);
    },
    m(r, i) {
      ve(t, r, i), n = !0;
    },
    p(r, i) {
      const s = {};
      i & /*step*/
      4 && (s.step = /*step*/
      r[2]), t.$set(s);
    },
    i(r) {
      n || (P(t.$$.fragment, r), n = !0);
    },
    o(r) {
      F(t.$$.fragment, r), n = !1;
    },
    d(r) {
      ye(t, r);
    }
  };
}
function xo(e) {
  let t, n = !N(
    /*step*/
    e[2].options.title
  ) || /*step*/
  e[2].options.cancelIcon && /*step*/
  e[2].options.cancelIcon.enabled, r, i = !N(
    /*step*/
    e[2].options.text
  ), s, o = Array.isArray(
    /*step*/
    e[2].options.buttons
  ) && /*step*/
  e[2].options.buttons.length, c, a = n && Rn(e), u = i && Tn(e), f = o && Cn(e);
  return {
    c() {
      t = se("div"), a && a.c(), r = ut(), u && u.c(), s = ut(), f && f.c(), I(t, "class", "shepherd-content");
    },
    m(h, d) {
      re(h, t, d), a && a.m(t, null), We(t, r), u && u.m(t, null), We(t, s), f && f.m(t, null), c = !0;
    },
    p(h, [d]) {
      d & /*step*/
      4 && (n = !N(
        /*step*/
        h[2].options.title
      ) || /*step*/
      h[2].options.cancelIcon && /*step*/
      h[2].options.cancelIcon.enabled), n ? a ? (a.p(h, d), d & /*step*/
      4 && P(a, 1)) : (a = Rn(h), a.c(), P(a, 1), a.m(t, r)) : a && (Se(), F(a, 1, 1, () => {
        a = null;
      }), Oe()), d & /*step*/
      4 && (i = !N(
        /*step*/
        h[2].options.text
      )), i ? u ? (u.p(h, d), d & /*step*/
      4 && P(u, 1)) : (u = Tn(h), u.c(), P(u, 1), u.m(t, s)) : u && (Se(), F(u, 1, 1, () => {
        u = null;
      }), Oe()), d & /*step*/
      4 && (o = Array.isArray(
        /*step*/
        h[2].options.buttons
      ) && /*step*/
      h[2].options.buttons.length), o ? f ? (f.p(h, d), d & /*step*/
      4 && P(f, 1)) : (f = Cn(h), f.c(), P(f, 1), f.m(t, null)) : f && (Se(), F(f, 1, 1, () => {
        f = null;
      }), Oe());
    },
    i(h) {
      c || (P(a), P(u), P(f), c = !0);
    },
    o(h) {
      F(a), F(u), F(f), c = !1;
    },
    d(h) {
      h && Z(t), a && a.d(), u && u.d(), f && f.d();
    }
  };
}
function Eo(e, t, n) {
  let {
    descriptionId: r,
    labelId: i,
    step: s
  } = t;
  return e.$$set = (o) => {
    "descriptionId" in o && n(0, r = o.descriptionId), "labelId" in o && n(1, i = o.labelId), "step" in o && n(2, s = o.step);
  }, [r, i, s];
}
class So extends de {
  constructor(t) {
    super(), fe(this, t, Eo, xo, ue, {
      descriptionId: 0,
      labelId: 1,
      step: 2
    });
  }
}
function An(e) {
  let t;
  return {
    c() {
      t = se("div"), I(t, "class", "shepherd-arrow"), I(t, "data-popper-arrow", "");
    },
    m(n, r) {
      re(n, t, r);
    },
    d(n) {
      n && Z(t);
    }
  };
}
function Oo(e) {
  let t, n, r, i, s, o, c, a, u = (
    /*step*/
    e[4].options.arrow && /*step*/
    e[4].options.attachTo && /*step*/
    e[4].options.attachTo.element && /*step*/
    e[4].options.attachTo.on && An()
  );
  r = new So({
    props: {
      descriptionId: (
        /*descriptionId*/
        e[2]
      ),
      labelId: (
        /*labelId*/
        e[3]
      ),
      step: (
        /*step*/
        e[4]
      )
    }
  });
  let f = [
    {
      "aria-describedby": i = N(
        /*step*/
        e[4].options.text
      ) ? null : (
        /*descriptionId*/
        e[2]
      )
    },
    {
      "aria-labelledby": s = /*step*/
      e[4].options.title ? (
        /*labelId*/
        e[3]
      ) : null
    },
    /*dataStepId*/
    e[1],
    {
      role: "dialog"
    },
    {
      tabindex: "0"
    }
  ], h = {};
  for (let d = 0; d < f.length; d += 1)
    h = Hi(h, f[d]);
  return {
    c() {
      t = se("div"), u && u.c(), n = ut(), Ce(r.$$.fragment), vn(t, h), ke(
        t,
        "shepherd-has-cancel-icon",
        /*hasCancelIcon*/
        e[5]
      ), ke(
        t,
        "shepherd-has-title",
        /*hasTitle*/
        e[6]
      ), ke(t, "shepherd-element", !0);
    },
    m(d, g) {
      re(d, t, g), u && u.m(t, null), We(t, n), ve(r, t, null), e[13](t), o = !0, c || (a = pt(
        t,
        "keydown",
        /*handleKeyDown*/
        e[7]
      ), c = !0);
    },
    p(d, [g]) {
      /*step*/
      d[4].options.arrow && /*step*/
      d[4].options.attachTo && /*step*/
      d[4].options.attachTo.element && /*step*/
      d[4].options.attachTo.on ? u || (u = An(), u.c(), u.m(t, n)) : u && (u.d(1), u = null);
      const v = {};
      g & /*descriptionId*/
      4 && (v.descriptionId = /*descriptionId*/
      d[2]), g & /*labelId*/
      8 && (v.labelId = /*labelId*/
      d[3]), g & /*step*/
      16 && (v.step = /*step*/
      d[4]), r.$set(v), vn(t, h = eo(f, [(!o || g & /*step, descriptionId*/
      20 && i !== (i = N(
        /*step*/
        d[4].options.text
      ) ? null : (
        /*descriptionId*/
        d[2]
      ))) && {
        "aria-describedby": i
      }, (!o || g & /*step, labelId*/
      24 && s !== (s = /*step*/
      d[4].options.title ? (
        /*labelId*/
        d[3]
      ) : null)) && {
        "aria-labelledby": s
      }, g & /*dataStepId*/
      2 && /*dataStepId*/
      d[1], {
        role: "dialog"
      }, {
        tabindex: "0"
      }])), ke(
        t,
        "shepherd-has-cancel-icon",
        /*hasCancelIcon*/
        d[5]
      ), ke(
        t,
        "shepherd-has-title",
        /*hasTitle*/
        d[6]
      ), ke(t, "shepherd-element", !0);
    },
    i(d) {
      o || (P(r.$$.fragment, d), o = !0);
    },
    o(d) {
      F(r.$$.fragment, d), o = !1;
    },
    d(d) {
      d && Z(t), u && u.d(), ye(r), e[13](null), c = !1, a();
    }
  };
}
const Ro = 9, To = 27, Co = 37, Ao = 39;
function Pn(e) {
  return e.split(" ").filter((t) => !!t.length);
}
function Po(e, t, n) {
  let {
    classPrefix: r,
    element: i,
    descriptionId: s,
    firstFocusableElement: o,
    focusableElements: c,
    labelId: a,
    lastFocusableElement: u,
    step: f,
    dataStepId: h
  } = t, d, g, v;
  const x = () => i;
  Ki(() => {
    n(1, h = {
      [`data-${r}shepherd-step-id`]: f.id
    }), n(9, c = i.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]')), n(8, o = c[0]), n(10, u = c[c.length - 1]);
  }), Ut(() => {
    v !== f.options.classes && S();
  });
  function S() {
    w(v), v = f.options.classes, _(v);
  }
  function w(m) {
    if (Je(m)) {
      const T = Pn(m);
      T.length && i.classList.remove(...T);
    }
  }
  function _(m) {
    if (Je(m)) {
      const T = Pn(m);
      T.length && i.classList.add(...T);
    }
  }
  const R = (m) => {
    const {
      tour: T
    } = f;
    switch (m.keyCode) {
      case Ro:
        if (c.length === 0) {
          m.preventDefault();
          break;
        }
        m.shiftKey ? (document.activeElement === o || document.activeElement.classList.contains("shepherd-element")) && (m.preventDefault(), u.focus()) : document.activeElement === u && (m.preventDefault(), o.focus());
        break;
      case To:
        T.options.exitOnEsc && (m.preventDefault(), m.stopPropagation(), f.cancel());
        break;
      case Co:
        T.options.keyboardNavigation && (m.preventDefault(), m.stopPropagation(), T.back());
        break;
      case Ao:
        T.options.keyboardNavigation && (m.preventDefault(), m.stopPropagation(), T.next());
        break;
    }
  };
  function y(m) {
    $e[m ? "unshift" : "push"](() => {
      i = m, n(0, i);
    });
  }
  return e.$$set = (m) => {
    "classPrefix" in m && n(11, r = m.classPrefix), "element" in m && n(0, i = m.element), "descriptionId" in m && n(2, s = m.descriptionId), "firstFocusableElement" in m && n(8, o = m.firstFocusableElement), "focusableElements" in m && n(9, c = m.focusableElements), "labelId" in m && n(3, a = m.labelId), "lastFocusableElement" in m && n(10, u = m.lastFocusableElement), "step" in m && n(4, f = m.step), "dataStepId" in m && n(1, h = m.dataStepId);
  }, e.$$.update = () => {
    e.$$.dirty & /*step*/
    16 && (n(5, d = f.options && f.options.cancelIcon && f.options.cancelIcon.enabled), n(6, g = f.options && f.options.title));
  }, [i, h, s, a, f, d, g, R, o, c, u, r, x, y];
}
class ko extends de {
  constructor(t) {
    super(), fe(this, t, Po, Oo, ue, {
      classPrefix: 11,
      element: 0,
      descriptionId: 2,
      firstFocusableElement: 8,
      focusableElements: 9,
      labelId: 3,
      lastFocusableElement: 10,
      step: 4,
      dataStepId: 1,
      getElement: 12
    });
  }
  get getElement() {
    return this.$$.ctx[12];
  }
}
class Mt extends Ft {
  constructor(t, n = {}) {
    return super(), this._resolvedAttachTo = void 0, this.classPrefix = void 0, this.el = void 0, this.target = void 0, this.tour = void 0, this.tour = t, this.classPrefix = this.tour.options ? Dn(this.tour.options.classPrefix) : "", this.styles = t.styles, this._resolvedAttachTo = null, Dt(this), this._setOptions(n), this;
  }
  /**
   * Cancel the tour
   * Triggers the `cancel` event
   */
  cancel() {
    this.tour.cancel(), this.trigger("cancel");
  }
  /**
   * Complete the tour
   * Triggers the `complete` event
   */
  complete() {
    this.tour.complete(), this.trigger("complete");
  }
  /**
   * Remove the step, delete the step's element, and destroy the FloatingUI instance for the step.
   * Triggers `destroy` event
   */
  destroy() {
    ji(this), Ge(this.el) && (this.el.remove(), this.el = null), this._updateStepTargetOnHide(), this.trigger("destroy");
  }
  /**
   * Returns the tour for the step
   * @return The tour instance
   */
  getTour() {
    return this.tour;
  }
  /**
   * Hide the step
   */
  hide() {
    var t;
    (t = this.tour.modal) == null || t.hide(), this.trigger("before-hide"), this.el && (this.el.hidden = !0), this._updateStepTargetOnHide(), this.trigger("hide");
  }
  /**
   * Resolves attachTo options.
   * @returns {{}|{element, on}}
   */
  _resolveAttachToOptions() {
    return this._resolvedAttachTo = Gr(this), this._resolvedAttachTo;
  }
  /**
   * A selector for resolved attachTo options.
   * @returns {{}|{element, on}}
   * @private
   */
  _getResolvedAttachToOptions() {
    return this._resolvedAttachTo === null ? this._resolveAttachToOptions() : this._resolvedAttachTo;
  }
  /**
   * Check if the step is open and visible
   * @return True if the step is open and visible
   */
  isOpen() {
    return !!(this.el && !this.el.hidden);
  }
  /**
   * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show
   */
  show() {
    return pe(this.options.beforeShowPromise) ? Promise.resolve(this.options.beforeShowPromise()).then(() => this._show()) : Promise.resolve(this._show());
  }
  /**
   * Updates the options of the step.
   *
   * @param {StepOptions} options The options for the step
   */
  updateStepOptions(t) {
    Object.assign(this.options, t), this.shepherdElementComponent && this.shepherdElementComponent.$set({
      step: this
    });
  }
  /**
   * Returns the element for the step
   * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed
   */
  getElement() {
    return this.el;
  }
  /**
   * Returns the target for the step
   * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found
   */
  getTarget() {
    return this.target;
  }
  /**
   * Creates Shepherd element for step based on options
   *
   * @return {HTMLElement} The DOM element for the step tooltip
   * @private
   */
  _createTooltipContent() {
    const t = `${this.id}-description`, n = `${this.id}-label`;
    return this.shepherdElementComponent = new ko({
      target: this.tour.options.stepsContainer || document.body,
      props: {
        classPrefix: this.classPrefix,
        descriptionId: t,
        labelId: n,
        step: this,
        // @ts-expect-error TODO: investigate where styles comes from
        styles: this.styles
      }
    }), this.shepherdElementComponent.getElement();
  }
  /**
   * If a custom scrollToHandler is defined, call that, otherwise do the generic
   * scrollIntoView call.
   *
   * @param {boolean | ScrollIntoViewOptions} scrollToOptions - If true, uses the default `scrollIntoView`,
   * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`
   * @private
   */
  _scrollTo(t) {
    const {
      element: n
    } = this._getResolvedAttachToOptions();
    pe(this.options.scrollToHandler) ? this.options.scrollToHandler(n) : Ir(n) && typeof n.scrollIntoView == "function" && n.scrollIntoView(t);
  }
  /**
   * _getClassOptions gets all possible classes for the step
   * @param {StepOptions} stepOptions The step specific options
   * @returns {string} unique string from array of classes
   */
  _getClassOptions(t) {
    const n = this.tour && this.tour.options && this.tour.options.defaultStepOptions, r = t.classes ? t.classes : "", i = n && n.classes ? n.classes : "", s = [...r.split(" "), ...i.split(" ")], o = new Set(s);
    return Array.from(o).join(" ").trim();
  }
  /**
   * Sets the options for the step, maps `when` to events, sets up buttons
   * @param options - The options for the step
   */
  _setOptions(t = {}) {
    let n = this.tour && this.tour.options && this.tour.options.defaultStepOptions;
    n = Lt({}, n || {}), this.options = Object.assign({
      arrow: !0
    }, n, t, Di(n, t));
    const {
      when: r
    } = this.options;
    this.options.classes = this._getClassOptions(t), this.destroy(), this.id = this.options.id || `step-${Bn()}`, r && Object.keys(r).forEach((i) => {
      this.on(i, r[i], this);
    });
  }
  /**
   * Create the element and set up the FloatingUI instance
   * @private
   */
  _setupElements() {
    N(this.el) || this.destroy(), this.el = this._createTooltipContent(), this.options.advanceOn && Jr(this), Li(this);
  }
  /**
   * Triggers `before-show`, generates the tooltip DOM content,
   * sets up a FloatingUI instance for the tooltip, then triggers `show`.
   * @private
   */
  _show() {
    var t;
    this.trigger("before-show"), this._resolveAttachToOptions(), this._setupElements(), this.tour.modal || this.tour.setupModal(), (t = this.tour.modal) == null || t.setupForStep(this), this._styleTargetElementForStep(this), this.el && (this.el.hidden = !1), this.options.scrollTo && setTimeout(() => {
      this._scrollTo(this.options.scrollTo);
    }), this.el && (this.el.hidden = !1);
    const n = this.shepherdElementComponent.getElement(), r = this.target || document.body;
    r.classList.add(`${this.classPrefix}shepherd-enabled`), r.classList.add(`${this.classPrefix}shepherd-target`), n.classList.add("shepherd-enabled"), this.trigger("show");
  }
  /**
   * Modulates the styles of the passed step's target element, based on the step's options and
   * the tour's `modal` option, to visually emphasize the element
   *
   * @param {Step} step The step object that attaches to the element
   * @private
   */
  _styleTargetElementForStep(t) {
    const n = t.target;
    n && (t.options.highlightClass && n.classList.add(t.options.highlightClass), n.classList.remove("shepherd-target-click-disabled"), t.options.canClickTarget === !1 && n.classList.add("shepherd-target-click-disabled"));
  }
  /**
   * When a step is hidden, remove the highlightClass and 'shepherd-enabled'
   * and 'shepherd-target' classes
   * @private
   */
  _updateStepTargetOnHide() {
    const t = this.target || document.body;
    this.options.highlightClass && t.classList.remove(this.options.highlightClass), t.classList.remove("shepherd-target-click-disabled", `${this.classPrefix}shepherd-enabled`, `${this.classPrefix}shepherd-target`);
  }
}
function Io(e) {
  if (e) {
    const {
      steps: t
    } = e;
    t.forEach((n) => {
      n.options && n.options.canClickTarget === !1 && n.options.attachTo && Ge(n.target) && n.target.classList.remove("shepherd-target-click-disabled");
    });
  }
}
function Mo({
  width: e,
  height: t,
  x: n = 0,
  y: r = 0,
  r: i = 0
}) {
  const {
    innerWidth: s,
    innerHeight: o
  } = window, {
    topLeft: c = 0,
    topRight: a = 0,
    bottomRight: u = 0,
    bottomLeft: f = 0
  } = typeof i == "number" ? {
    topLeft: i,
    topRight: i,
    bottomRight: i,
    bottomLeft: i
  } : i;
  return `M${s},${o}H0V0H${s}V${o}ZM${n + c},${r}a${c},${c},0,0,0-${c},${c}V${t + r - f}a${f},${f},0,0,0,${f},${f}H${e + n - u}a${u},${u},0,0,0,${u}-${u}V${r + a}a${a},${a},0,0,0-${a}-${a}Z`;
}
function Fo(e) {
  let t, n, r, i, s;
  return {
    c() {
      t = bn("svg"), n = bn("path"), I(
        n,
        "d",
        /*pathDefinition*/
        e[2]
      ), I(t, "class", r = `${/*modalIsVisible*/
      e[1] ? "shepherd-modal-is-visible" : ""} shepherd-modal-overlay-container`);
    },
    m(o, c) {
      re(o, t, c), We(t, n), e[11](t), i || (s = pt(
        t,
        "touchmove",
        /*_preventModalOverlayTouch*/
        e[3]
      ), i = !0);
    },
    p(o, [c]) {
      c & /*pathDefinition*/
      4 && I(
        n,
        "d",
        /*pathDefinition*/
        o[2]
      ), c & /*modalIsVisible*/
      2 && r !== (r = `${/*modalIsVisible*/
      o[1] ? "shepherd-modal-is-visible" : ""} shepherd-modal-overlay-container`) && I(t, "class", r);
    },
    i: J,
    o: J,
    d(o) {
      o && Z(t), e[11](null), i = !1, s();
    }
  };
}
function Zn(e) {
  if (!e)
    return null;
  const n = e instanceof HTMLElement && window.getComputedStyle(e).overflowY;
  return n !== "hidden" && n !== "visible" && e.scrollHeight >= e.clientHeight ? e : Zn(e.parentElement);
}
function Lo(e) {
  let t = {
    top: 0,
    left: 0
  };
  if (!e)
    return t;
  let n = e.ownerDocument.defaultView;
  for (; n !== window.top; ) {
    var r;
    const o = (r = n) == null ? void 0 : r.frameElement;
    if (o) {
      var i, s;
      const c = o.getBoundingClientRect();
      t.top += c.top + ((i = c.scrollTop) != null ? i : 0), t.left += c.left + ((s = c.scrollLeft) != null ? s : 0);
    }
    n = n.parent;
  }
  return t;
}
function Do(e, t) {
  const n = e.getBoundingClientRect();
  let r = n.y || n.top, i = n.bottom || r + n.height;
  if (t) {
    const o = t.getBoundingClientRect(), c = o.y || o.top, a = o.bottom || c + o.height;
    r = Math.max(r, c), i = Math.min(i, a);
  }
  const s = Math.max(i - r, 0);
  return {
    y: r,
    height: s
  };
}
function jo(e, t, n) {
  let {
    element: r,
    openingProperties: i
  } = t, s = !1, o, c;
  u();
  const a = () => r;
  function u() {
    n(4, i = {
      width: 0,
      height: 0,
      x: 0,
      y: 0,
      r: 0
    });
  }
  function f() {
    n(1, s = !1), w();
  }
  function h(y = 0, m = 0, T = 0, B = 0, ie, H) {
    if (H) {
      const {
        y: K,
        height: U
      } = Do(H, ie), {
        x: W,
        width: j,
        left: L
      } = H.getBoundingClientRect();
      n(4, i = {
        width: j + y * 2,
        height: U + y * 2,
        x: (W || L) + T - y,
        y: K + B - y,
        r: m
      });
    } else
      u();
  }
  function d(y) {
    w(), y.tour.options.useModalOverlay ? (_(y), g()) : f();
  }
  function g() {
    n(1, s = !0);
  }
  const v = (y) => {
    y.preventDefault();
  }, x = (y) => {
    y.stopPropagation();
  };
  function S() {
    window.addEventListener("touchmove", v, {
      passive: !1
    });
  }
  function w() {
    o && (cancelAnimationFrame(o), o = void 0), window.removeEventListener("touchmove", v, {
      passive: !1
    });
  }
  function _(y) {
    const {
      modalOverlayOpeningPadding: m,
      modalOverlayOpeningRadius: T,
      modalOverlayOpeningXOffset: B = 0,
      modalOverlayOpeningYOffset: ie = 0
    } = y.options, H = Lo(y.target), K = Zn(y.target), U = () => {
      o = void 0, h(m, T, B + H.left, ie + H.top, K, y.target), o = requestAnimationFrame(U);
    };
    U(), S();
  }
  function R(y) {
    $e[y ? "unshift" : "push"](() => {
      r = y, n(0, r);
    });
  }
  return e.$$set = (y) => {
    "element" in y && n(0, r = y.element), "openingProperties" in y && n(4, i = y.openingProperties);
  }, e.$$.update = () => {
    e.$$.dirty & /*openingProperties*/
    16 && n(2, c = Mo(i));
  }, [r, s, c, x, i, a, u, f, h, d, g, R];
}
class Bo extends de {
  constructor(t) {
    super(), fe(this, t, jo, Fo, ue, {
      element: 0,
      openingProperties: 4,
      getElement: 5,
      closeModalOpening: 6,
      hide: 7,
      positionModal: 8,
      setupForStep: 9,
      show: 10
    });
  }
  get getElement() {
    return this.$$.ctx[5];
  }
  get closeModalOpening() {
    return this.$$.ctx[6];
  }
  get hide() {
    return this.$$.ctx[7];
  }
  get positionModal() {
    return this.$$.ctx[8];
  }
  get setupForStep() {
    return this.$$.ctx[9];
  }
  get show() {
    return this.$$.ctx[10];
  }
}
class No extends Ft {
  constructor() {
    super(), this.activeTour = void 0, Dt(this);
  }
}
class Wo extends Ft {
  constructor(t = {}) {
    super(), this.trackedEvents = ["active", "cancel", "complete", "show"], this.classPrefix = void 0, this.currentStep = void 0, this.focusedElBeforeOpen = void 0, this.id = void 0, this.modal = void 0, this.options = void 0, this.steps = void 0, Dt(this);
    const n = {
      exitOnEsc: !0,
      keyboardNavigation: !0
    };
    return this.options = Object.assign({}, n, t), this.classPrefix = Dn(this.options.classPrefix), this.steps = [], this.addSteps(this.options.steps), ["active", "cancel", "complete", "inactive", "show", "start"].map((i) => {
      ((s) => {
        this.on(s, (o) => {
          o = o || {}, o.tour = this, xe.trigger(s, o);
        });
      })(i);
    }), this._setTourID(t.id), this;
  }
  /**
   * Adds a new step to the tour
   * @param {StepOptions} options - An object containing step options or a Step instance
   * @param {number | undefined} index - The optional index to insert the step at. If undefined, the step
   * is added to the end of the array.
   * @return The newly added step
   */
  addStep(t, n) {
    let r = t;
    return r instanceof Mt ? r.tour = this : r = new Mt(this, r), N(n) ? this.steps.push(r) : this.steps.splice(n, 0, r), r;
  }
  /**
   * Add multiple steps to the tour
   * @param {Array<StepOptions> | Array<Step> | undefined} steps - The steps to add to the tour
   */
  addSteps(t) {
    return Array.isArray(t) && t.forEach((n) => {
      this.addStep(n);
    }), this;
  }
  /**
   * Go to the previous step in the tour
   */
  back() {
    const t = this.steps.indexOf(this.currentStep);
    this.show(t - 1, !1);
  }
  /**
   * Calls _done() triggering the 'cancel' event
   * If `confirmCancel` is true, will show a window.confirm before cancelling
   * If `confirmCancel` is a function, will call it and wait for the return value,
   * and only cancel when the value returned is true
   */
  async cancel() {
    if (this.options.confirmCancel) {
      const t = this.options.confirmCancelMessage || "Are you sure you want to stop the tour?";
      let n;
      pe(this.options.confirmCancel) ? n = await this.options.confirmCancel() : n = window.confirm(t), n && this._done("cancel");
    } else
      this._done("cancel");
  }
  /**
   * Calls _done() triggering the `complete` event
   */
  complete() {
    this._done("complete");
  }
  /**
   * Gets the step from a given id
   * @param {number | string} id - The id of the step to retrieve
   * @return The step corresponding to the `id`
   */
  getById(t) {
    return this.steps.find((n) => n.id === t);
  }
  /**
   * Gets the current step
   */
  getCurrentStep() {
    return this.currentStep;
  }
  /**
   * Hide the current step
   */
  hide() {
    const t = this.getCurrentStep();
    if (t)
      return t.hide();
  }
  /**
   * Check if the tour is active
   */
  isActive() {
    return xe.activeTour === this;
  }
  /**
   * Go to the next step in the tour
   * If we are at the end, call `complete`
   */
  next() {
    const t = this.steps.indexOf(this.currentStep);
    t === this.steps.length - 1 ? this.complete() : this.show(t + 1, !0);
  }
  /**
   * Removes the step from the tour
   * @param {string} name - The id for the step to remove
   */
  removeStep(t) {
    const n = this.getCurrentStep();
    this.steps.some((r, i) => {
      if (r.id === t)
        return r.isOpen() && r.hide(), r.destroy(), this.steps.splice(i, 1), !0;
    }), n && n.id === t && (this.currentStep = void 0, this.steps.length ? this.show(0) : this.cancel());
  }
  /**
   * Show a specific step in the tour
   * @param {number | string} key - The key to look up the step by
   * @param {boolean} forward - True if we are going forward, false if backward
   */
  show(t = 0, n = !0) {
    const r = Je(t) ? this.getById(t) : this.steps[t];
    r && (this._updateStateBeforeShow(), pe(r.options.showOn) && !r.options.showOn() ? this._skipStep(r, n) : (this.trigger("show", {
      step: r,
      previous: this.currentStep
    }), this.currentStep = r, r.show()));
  }
  /**
   * Start the tour
   */
  async start() {
    this.trigger("start"), this.focusedElBeforeOpen = document.activeElement, this.currentStep = null, this.setupModal(), this._setupActiveTour(), this.next();
  }
  /**
   * Called whenever the tour is cancelled or completed, basically anytime we exit the tour
   * @param {string} event - The event name to trigger
   * @private
   */
  _done(t) {
    const n = this.steps.indexOf(this.currentStep);
    if (Array.isArray(this.steps) && this.steps.forEach((r) => r.destroy()), Io(this), this.trigger(t, {
      index: n
    }), xe.activeTour = null, this.trigger("inactive", {
      tour: this
    }), this.modal && this.modal.hide(), (t === "cancel" || t === "complete") && this.modal) {
      const r = document.querySelector(".shepherd-modal-overlay-container");
      r && (r.remove(), this.modal = null);
    }
    Ge(this.focusedElBeforeOpen) && this.focusedElBeforeOpen.focus();
  }
  /**
   * Make this tour "active"
   */
  _setupActiveTour() {
    this.trigger("active", {
      tour: this
    }), xe.activeTour = this;
  }
  /**
   * setupModal create the modal container and instance
   */
  setupModal() {
    this.modal = new Bo({
      target: this.options.modalContainer || document.body,
      props: {
        // @ts-expect-error TODO: investigate where styles comes from
        styles: this.styles
      }
    });
  }
  /**
   * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step
   * @param {Step} step - The step to skip
   * @param {boolean} forward - True if we are going forward, false if backward
   * @private
   */
  _skipStep(t, n) {
    const r = this.steps.indexOf(t);
    if (r === this.steps.length - 1)
      this.complete();
    else {
      const i = n ? r + 1 : r - 1;
      this.show(i, n);
    }
  }
  /**
   * Before showing, hide the current step and if the tour is not
   * already active, call `this._setupActiveTour`.
   * @private
   */
  _updateStateBeforeShow() {
    this.currentStep && this.currentStep.hide(), this.isActive() || this._setupActiveTour();
  }
  /**
   * Sets this.id to a provided tourName and id or `${tourName}--${uuid}`
   * @param {string} optionsId - True if we are going forward, false if backward
   * @private
   */
  _setTourID(t) {
    const n = this.options.tourName || "tour", r = t || Bn();
    this.id = `${n}--${r}`;
  }
}
const xe = new No(), Qn = typeof window > "u";
xe.Step = Qn ? Kr : Mt;
xe.Tour = Qn ? Xr : Wo;
const Yt = Tr(
  void 0
), Vo = Yt.Consumer, Ho = () => {
  const e = Cr(Yt);
  if (!e)
    throw new Error(
      "useShepherd must be used within a ShepherdJourneyProvider"
    );
  const { Shepherd: t } = e;
  return t;
}, Uo = ({
  children: e
}) => /* @__PURE__ */ kr.jsx(Yt.Provider, { value: { Shepherd: xe }, children: e });
export {
  Vo as JourneyMethods,
  Yt as ShepherdJourneyContext,
  Uo as ShepherdJourneyProvider,
  Ho as useShepherd
};
